// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
)

type FakeCheck struct {
	AcquireTrackingLockStub        func(lager.Logger) (lock.Lock, bool, error)
	acquireTrackingLockMutex       sync.RWMutex
	acquireTrackingLockArgsForCall []struct {
		arg1 lager.Logger
	}
	acquireTrackingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireTrackingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	BaseResourceTypeIDStub        func() int
	baseResourceTypeIDMutex       sync.RWMutex
	baseResourceTypeIDArgsForCall []struct {
	}
	baseResourceTypeIDReturns struct {
		result1 int
	}
	baseResourceTypeIDReturnsOnCall map[int]struct {
		result1 int
	}
	CreateTimeStub        func() time.Time
	createTimeMutex       sync.RWMutex
	createTimeArgsForCall []struct {
	}
	createTimeReturns struct {
		result1 time.Time
	}
	createTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	EndTimeStub        func() time.Time
	endTimeMutex       sync.RWMutex
	endTimeArgsForCall []struct {
	}
	endTimeReturns struct {
		result1 time.Time
	}
	endTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	FinishStub        func() error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	FinishWithErrorStub        func(error) error
	finishWithErrorMutex       sync.RWMutex
	finishWithErrorArgsForCall []struct {
		arg1 error
	}
	finishWithErrorReturns struct {
		result1 error
	}
	finishWithErrorReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IsRunningStub        func() bool
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct {
	}
	isRunningReturns struct {
		result1 bool
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	PlanStub        func() atc.Plan
	planMutex       sync.RWMutex
	planArgsForCall []struct {
	}
	planReturns struct {
		result1 atc.Plan
	}
	planReturnsOnCall map[int]struct {
		result1 atc.Plan
	}
	ResourceConfigIDStub        func() int
	resourceConfigIDMutex       sync.RWMutex
	resourceConfigIDArgsForCall []struct {
	}
	resourceConfigIDReturns struct {
		result1 int
	}
	resourceConfigIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceConfigScopeIDStub        func() int
	resourceConfigScopeIDMutex       sync.RWMutex
	resourceConfigScopeIDArgsForCall []struct {
	}
	resourceConfigScopeIDReturns struct {
		result1 int
	}
	resourceConfigScopeIDReturnsOnCall map[int]struct {
		result1 int
	}
	SaveVersionsStub        func([]atc.Version) error
	saveVersionsMutex       sync.RWMutex
	saveVersionsArgsForCall []struct {
		arg1 []atc.Version
	}
	saveVersionsReturns struct {
		result1 error
	}
	saveVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	SchemaStub        func() string
	schemaMutex       sync.RWMutex
	schemaArgsForCall []struct {
	}
	schemaReturns struct {
		result1 string
	}
	schemaReturnsOnCall map[int]struct {
		result1 string
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StatusStub        func() db.CheckStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 db.CheckStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.CheckStatus
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCheck) AcquireTrackingLock(arg1 lager.Logger) (lock.Lock, bool, error) {
	fake.acquireTrackingLockMutex.Lock()
	ret, specificReturn := fake.acquireTrackingLockReturnsOnCall[len(fake.acquireTrackingLockArgsForCall)]
	fake.acquireTrackingLockArgsForCall = append(fake.acquireTrackingLockArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("AcquireTrackingLock", []interface{}{arg1})
	fake.acquireTrackingLockMutex.Unlock()
	if fake.AcquireTrackingLockStub != nil {
		return fake.AcquireTrackingLockStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireTrackingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheck) AcquireTrackingLockCallCount() int {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return len(fake.acquireTrackingLockArgsForCall)
}

func (fake *FakeCheck) AcquireTrackingLockCalls(stub func(lager.Logger) (lock.Lock, bool, error)) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = stub
}

func (fake *FakeCheck) AcquireTrackingLockArgsForCall(i int) lager.Logger {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	argsForCall := fake.acquireTrackingLockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) AcquireTrackingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	fake.acquireTrackingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) AcquireTrackingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	if fake.acquireTrackingLockReturnsOnCall == nil {
		fake.acquireTrackingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireTrackingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) BaseResourceTypeID() int {
	fake.baseResourceTypeIDMutex.Lock()
	ret, specificReturn := fake.baseResourceTypeIDReturnsOnCall[len(fake.baseResourceTypeIDArgsForCall)]
	fake.baseResourceTypeIDArgsForCall = append(fake.baseResourceTypeIDArgsForCall, struct {
	}{})
	fake.recordInvocation("BaseResourceTypeID", []interface{}{})
	fake.baseResourceTypeIDMutex.Unlock()
	if fake.BaseResourceTypeIDStub != nil {
		return fake.BaseResourceTypeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.baseResourceTypeIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) BaseResourceTypeIDCallCount() int {
	fake.baseResourceTypeIDMutex.RLock()
	defer fake.baseResourceTypeIDMutex.RUnlock()
	return len(fake.baseResourceTypeIDArgsForCall)
}

func (fake *FakeCheck) BaseResourceTypeIDCalls(stub func() int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = stub
}

func (fake *FakeCheck) BaseResourceTypeIDReturns(result1 int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = nil
	fake.baseResourceTypeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) BaseResourceTypeIDReturnsOnCall(i int, result1 int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = nil
	if fake.baseResourceTypeIDReturnsOnCall == nil {
		fake.baseResourceTypeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.baseResourceTypeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) CreateTime() time.Time {
	fake.createTimeMutex.Lock()
	ret, specificReturn := fake.createTimeReturnsOnCall[len(fake.createTimeArgsForCall)]
	fake.createTimeArgsForCall = append(fake.createTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateTime", []interface{}{})
	fake.createTimeMutex.Unlock()
	if fake.CreateTimeStub != nil {
		return fake.CreateTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) CreateTimeCallCount() int {
	fake.createTimeMutex.RLock()
	defer fake.createTimeMutex.RUnlock()
	return len(fake.createTimeArgsForCall)
}

func (fake *FakeCheck) CreateTimeCalls(stub func() time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = stub
}

func (fake *FakeCheck) CreateTimeReturns(result1 time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = nil
	fake.createTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) CreateTimeReturnsOnCall(i int, result1 time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = nil
	if fake.createTimeReturnsOnCall == nil {
		fake.createTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.createTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) EndTime() time.Time {
	fake.endTimeMutex.Lock()
	ret, specificReturn := fake.endTimeReturnsOnCall[len(fake.endTimeArgsForCall)]
	fake.endTimeArgsForCall = append(fake.endTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("EndTime", []interface{}{})
	fake.endTimeMutex.Unlock()
	if fake.EndTimeStub != nil {
		return fake.EndTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) EndTimeCallCount() int {
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	return len(fake.endTimeArgsForCall)
}

func (fake *FakeCheck) EndTimeCalls(stub func() time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = stub
}

func (fake *FakeCheck) EndTimeReturns(result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	fake.endTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) EndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	if fake.endTimeReturnsOnCall == nil {
		fake.endTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.endTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) Finish() error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
	}{})
	fake.recordInvocation("Finish", []interface{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeCheck) FinishCalls(stub func() error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = stub
}

func (fake *FakeCheck) FinishReturns(result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishReturnsOnCall(i int, result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithError(arg1 error) error {
	fake.finishWithErrorMutex.Lock()
	ret, specificReturn := fake.finishWithErrorReturnsOnCall[len(fake.finishWithErrorArgsForCall)]
	fake.finishWithErrorArgsForCall = append(fake.finishWithErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("FinishWithError", []interface{}{arg1})
	fake.finishWithErrorMutex.Unlock()
	if fake.FinishWithErrorStub != nil {
		return fake.FinishWithErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishWithErrorReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishWithErrorCallCount() int {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return len(fake.finishWithErrorArgsForCall)
}

func (fake *FakeCheck) FinishWithErrorCalls(stub func(error) error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = stub
}

func (fake *FakeCheck) FinishWithErrorArgsForCall(i int) error {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	argsForCall := fake.finishWithErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) FinishWithErrorReturns(result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	fake.finishWithErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithErrorReturnsOnCall(i int, result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	if fake.finishWithErrorReturnsOnCall == nil {
		fake.finishWithErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishWithErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeCheck) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeCheck) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) IsRunning() bool {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct {
	}{})
	fake.recordInvocation("IsRunning", []interface{}{})
	fake.isRunningMutex.Unlock()
	if fake.IsRunningStub != nil {
		return fake.IsRunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isRunningReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeCheck) IsRunningCalls(stub func() bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = stub
}

func (fake *FakeCheck) IsRunningReturns(result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) IsRunningReturnsOnCall(i int, result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) Plan() atc.Plan {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct {
	}{})
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if fake.PlanStub != nil {
		return fake.PlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.planReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeCheck) PlanCalls(stub func() atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = stub
}

func (fake *FakeCheck) PlanReturns(result1 atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeCheck) PlanReturnsOnCall(i int, result1 atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 atc.Plan
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeCheck) ResourceConfigID() int {
	fake.resourceConfigIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigIDReturnsOnCall[len(fake.resourceConfigIDArgsForCall)]
	fake.resourceConfigIDArgsForCall = append(fake.resourceConfigIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfigID", []interface{}{})
	fake.resourceConfigIDMutex.Unlock()
	if fake.ResourceConfigIDStub != nil {
		return fake.ResourceConfigIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceConfigIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) ResourceConfigIDCallCount() int {
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	return len(fake.resourceConfigIDArgsForCall)
}

func (fake *FakeCheck) ResourceConfigIDCalls(stub func() int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = stub
}

func (fake *FakeCheck) ResourceConfigIDReturns(result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	fake.resourceConfigIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	if fake.resourceConfigIDReturnsOnCall == nil {
		fake.resourceConfigIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigScopeID() int {
	fake.resourceConfigScopeIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigScopeIDReturnsOnCall[len(fake.resourceConfigScopeIDArgsForCall)]
	fake.resourceConfigScopeIDArgsForCall = append(fake.resourceConfigScopeIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfigScopeID", []interface{}{})
	fake.resourceConfigScopeIDMutex.Unlock()
	if fake.ResourceConfigScopeIDStub != nil {
		return fake.ResourceConfigScopeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceConfigScopeIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) ResourceConfigScopeIDCallCount() int {
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	return len(fake.resourceConfigScopeIDArgsForCall)
}

func (fake *FakeCheck) ResourceConfigScopeIDCalls(stub func() int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = stub
}

func (fake *FakeCheck) ResourceConfigScopeIDReturns(result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	fake.resourceConfigScopeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigScopeIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	if fake.resourceConfigScopeIDReturnsOnCall == nil {
		fake.resourceConfigScopeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigScopeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) SaveVersions(arg1 []atc.Version) error {
	var arg1Copy []atc.Version
	if arg1 != nil {
		arg1Copy = make([]atc.Version, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.saveVersionsMutex.Lock()
	ret, specificReturn := fake.saveVersionsReturnsOnCall[len(fake.saveVersionsArgsForCall)]
	fake.saveVersionsArgsForCall = append(fake.saveVersionsArgsForCall, struct {
		arg1 []atc.Version
	}{arg1Copy})
	fake.recordInvocation("SaveVersions", []interface{}{arg1Copy})
	fake.saveVersionsMutex.Unlock()
	if fake.SaveVersionsStub != nil {
		return fake.SaveVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) SaveVersionsCallCount() int {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	return len(fake.saveVersionsArgsForCall)
}

func (fake *FakeCheck) SaveVersionsCalls(stub func([]atc.Version) error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = stub
}

func (fake *FakeCheck) SaveVersionsArgsForCall(i int) []atc.Version {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	argsForCall := fake.saveVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) SaveVersionsReturns(result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	fake.saveVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) SaveVersionsReturnsOnCall(i int, result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	if fake.saveVersionsReturnsOnCall == nil {
		fake.saveVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) Schema() string {
	fake.schemaMutex.Lock()
	ret, specificReturn := fake.schemaReturnsOnCall[len(fake.schemaArgsForCall)]
	fake.schemaArgsForCall = append(fake.schemaArgsForCall, struct {
	}{})
	fake.recordInvocation("Schema", []interface{}{})
	fake.schemaMutex.Unlock()
	if fake.SchemaStub != nil {
		return fake.SchemaStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.schemaReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) SchemaCallCount() int {
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	return len(fake.schemaArgsForCall)
}

func (fake *FakeCheck) SchemaCalls(stub func() string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = stub
}

func (fake *FakeCheck) SchemaReturns(result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	fake.schemaReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) SchemaReturnsOnCall(i int, result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	if fake.schemaReturnsOnCall == nil {
		fake.schemaReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.schemaReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeCheck) StartCalls(stub func() error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeCheck) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if fake.StartTimeStub != nil {
		return fake.StartTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeCheck) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeCheck) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) Status() db.CheckStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeCheck) StatusCalls(stub func() db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeCheck) StatusReturns(result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) StatusReturnsOnCall(i int, result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.CheckStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	fake.baseResourceTypeIDMutex.RLock()
	defer fake.baseResourceTypeIDMutex.RUnlock()
	fake.createTimeMutex.RLock()
	defer fake.createTimeMutex.RUnlock()
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCheck) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Check = new(FakeCheck)
