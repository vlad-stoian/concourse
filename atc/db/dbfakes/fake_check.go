// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
)

type FakeCheck struct {
	AcquireTrackingLockStub        func() (lock.Lock, bool, error)
	acquireTrackingLockMutex       sync.RWMutex
	acquireTrackingLockArgsForCall []struct {
	}
	acquireTrackingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireTrackingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	FinishStub        func() error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	FinishWithErrorStub        func(error) error
	finishWithErrorMutex       sync.RWMutex
	finishWithErrorArgsForCall []struct {
		arg1 error
	}
	finishWithErrorReturns struct {
		result1 error
	}
	finishWithErrorReturnsOnCall map[int]struct {
		result1 error
	}
	FromVersionStub        func() atc.Version
	fromVersionMutex       sync.RWMutex
	fromVersionArgsForCall []struct {
	}
	fromVersionReturns struct {
		result1 atc.Version
	}
	fromVersionReturnsOnCall map[int]struct {
		result1 atc.Version
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IsRunningStub        func() bool
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct {
	}
	isRunningReturns struct {
		result1 bool
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	ResourceConfigScopeStub        func() (db.ResourceConfigScope, error)
	resourceConfigScopeMutex       sync.RWMutex
	resourceConfigScopeArgsForCall []struct {
	}
	resourceConfigScopeReturns struct {
		result1 db.ResourceConfigScope
		result2 error
	}
	resourceConfigScopeReturnsOnCall map[int]struct {
		result1 db.ResourceConfigScope
		result2 error
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StatusStub        func() db.CheckStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 db.CheckStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.CheckStatus
	}
	TimeoutStub        func() time.Duration
	timeoutMutex       sync.RWMutex
	timeoutArgsForCall []struct {
	}
	timeoutReturns struct {
		result1 time.Duration
	}
	timeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCheck) AcquireTrackingLock() (lock.Lock, bool, error) {
	fake.acquireTrackingLockMutex.Lock()
	ret, specificReturn := fake.acquireTrackingLockReturnsOnCall[len(fake.acquireTrackingLockArgsForCall)]
	fake.acquireTrackingLockArgsForCall = append(fake.acquireTrackingLockArgsForCall, struct {
	}{})
	fake.recordInvocation("AcquireTrackingLock", []interface{}{})
	fake.acquireTrackingLockMutex.Unlock()
	if fake.AcquireTrackingLockStub != nil {
		return fake.AcquireTrackingLockStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireTrackingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheck) AcquireTrackingLockCallCount() int {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return len(fake.acquireTrackingLockArgsForCall)
}

func (fake *FakeCheck) AcquireTrackingLockCalls(stub func() (lock.Lock, bool, error)) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = stub
}

func (fake *FakeCheck) AcquireTrackingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	fake.acquireTrackingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) AcquireTrackingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	if fake.acquireTrackingLockReturnsOnCall == nil {
		fake.acquireTrackingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireTrackingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) Finish() error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
	}{})
	fake.recordInvocation("Finish", []interface{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeCheck) FinishCalls(stub func() error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = stub
}

func (fake *FakeCheck) FinishReturns(result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishReturnsOnCall(i int, result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithError(arg1 error) error {
	fake.finishWithErrorMutex.Lock()
	ret, specificReturn := fake.finishWithErrorReturnsOnCall[len(fake.finishWithErrorArgsForCall)]
	fake.finishWithErrorArgsForCall = append(fake.finishWithErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("FinishWithError", []interface{}{arg1})
	fake.finishWithErrorMutex.Unlock()
	if fake.FinishWithErrorStub != nil {
		return fake.FinishWithErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishWithErrorReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishWithErrorCallCount() int {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return len(fake.finishWithErrorArgsForCall)
}

func (fake *FakeCheck) FinishWithErrorCalls(stub func(error) error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = stub
}

func (fake *FakeCheck) FinishWithErrorArgsForCall(i int) error {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	argsForCall := fake.finishWithErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) FinishWithErrorReturns(result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	fake.finishWithErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithErrorReturnsOnCall(i int, result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	if fake.finishWithErrorReturnsOnCall == nil {
		fake.finishWithErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishWithErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FromVersion() atc.Version {
	fake.fromVersionMutex.Lock()
	ret, specificReturn := fake.fromVersionReturnsOnCall[len(fake.fromVersionArgsForCall)]
	fake.fromVersionArgsForCall = append(fake.fromVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("FromVersion", []interface{}{})
	fake.fromVersionMutex.Unlock()
	if fake.FromVersionStub != nil {
		return fake.FromVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fromVersionReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FromVersionCallCount() int {
	fake.fromVersionMutex.RLock()
	defer fake.fromVersionMutex.RUnlock()
	return len(fake.fromVersionArgsForCall)
}

func (fake *FakeCheck) FromVersionCalls(stub func() atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = stub
}

func (fake *FakeCheck) FromVersionReturns(result1 atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = nil
	fake.fromVersionReturns = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeCheck) FromVersionReturnsOnCall(i int, result1 atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = nil
	if fake.fromVersionReturnsOnCall == nil {
		fake.fromVersionReturnsOnCall = make(map[int]struct {
			result1 atc.Version
		})
	}
	fake.fromVersionReturnsOnCall[i] = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeCheck) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeCheck) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeCheck) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) IsRunning() bool {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct {
	}{})
	fake.recordInvocation("IsRunning", []interface{}{})
	fake.isRunningMutex.Unlock()
	if fake.IsRunningStub != nil {
		return fake.IsRunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isRunningReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeCheck) IsRunningCalls(stub func() bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = stub
}

func (fake *FakeCheck) IsRunningReturns(result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) IsRunningReturnsOnCall(i int, result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) ResourceConfigScope() (db.ResourceConfigScope, error) {
	fake.resourceConfigScopeMutex.Lock()
	ret, specificReturn := fake.resourceConfigScopeReturnsOnCall[len(fake.resourceConfigScopeArgsForCall)]
	fake.resourceConfigScopeArgsForCall = append(fake.resourceConfigScopeArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfigScope", []interface{}{})
	fake.resourceConfigScopeMutex.Unlock()
	if fake.ResourceConfigScopeStub != nil {
		return fake.ResourceConfigScopeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourceConfigScopeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheck) ResourceConfigScopeCallCount() int {
	fake.resourceConfigScopeMutex.RLock()
	defer fake.resourceConfigScopeMutex.RUnlock()
	return len(fake.resourceConfigScopeArgsForCall)
}

func (fake *FakeCheck) ResourceConfigScopeCalls(stub func() (db.ResourceConfigScope, error)) {
	fake.resourceConfigScopeMutex.Lock()
	defer fake.resourceConfigScopeMutex.Unlock()
	fake.ResourceConfigScopeStub = stub
}

func (fake *FakeCheck) ResourceConfigScopeReturns(result1 db.ResourceConfigScope, result2 error) {
	fake.resourceConfigScopeMutex.Lock()
	defer fake.resourceConfigScopeMutex.Unlock()
	fake.ResourceConfigScopeStub = nil
	fake.resourceConfigScopeReturns = struct {
		result1 db.ResourceConfigScope
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) ResourceConfigScopeReturnsOnCall(i int, result1 db.ResourceConfigScope, result2 error) {
	fake.resourceConfigScopeMutex.Lock()
	defer fake.resourceConfigScopeMutex.Unlock()
	fake.ResourceConfigScopeStub = nil
	if fake.resourceConfigScopeReturnsOnCall == nil {
		fake.resourceConfigScopeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigScope
			result2 error
		})
	}
	fake.resourceConfigScopeReturnsOnCall[i] = struct {
		result1 db.ResourceConfigScope
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeCheck) StartCalls(stub func() error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeCheck) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) Status() db.CheckStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeCheck) StatusCalls(stub func() db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeCheck) StatusReturns(result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) StatusReturnsOnCall(i int, result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.CheckStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) Timeout() time.Duration {
	fake.timeoutMutex.Lock()
	ret, specificReturn := fake.timeoutReturnsOnCall[len(fake.timeoutArgsForCall)]
	fake.timeoutArgsForCall = append(fake.timeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("Timeout", []interface{}{})
	fake.timeoutMutex.Unlock()
	if fake.TimeoutStub != nil {
		return fake.TimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.timeoutReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) TimeoutCallCount() int {
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	return len(fake.timeoutArgsForCall)
}

func (fake *FakeCheck) TimeoutCalls(stub func() time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = stub
}

func (fake *FakeCheck) TimeoutReturns(result1 time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = nil
	fake.timeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeCheck) TimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = nil
	if fake.timeoutReturnsOnCall == nil {
		fake.timeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.timeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeCheck) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	fake.fromVersionMutex.RLock()
	defer fake.fromVersionMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	fake.resourceConfigScopeMutex.RLock()
	defer fake.resourceConfigScopeMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCheck) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Check = new(FakeCheck)
